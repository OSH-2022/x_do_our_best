# 调研报告

## 小组成员

* 陆子睦
* 黄与进
* 刘津畅
* 唐星
* 杨涛



## 项目简介



随着智能硬件、物联网行业的迅猛发展, 嵌入式系统在各个领域都得到了广泛的应用。嵌入式操作系统可以帮助嵌入式设备更好地完成任务的调度，从而更高效地完成任务。然而，一开始由于嵌入式设备内存较少，一些主流的嵌入式操作系统如FreeRTOS并没有内存管理单元。随着时代的发展，内存的成本越来越低，嵌入式设备也在向着内存增加的方向发展。所以，按照当前的趋势，嵌入式操作系统也应该有自己的内存管理单元。嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。于是，我们小组决定为FreeRTOS编写一个内存管理单元，从而让其有更强大的任务调度能力。由于Rust是一门高效而且安全的语句，我们将使用Rust来进行编写。



而有了内存管理单元之后，嵌入式内核就有可能去以模块化的形式去调用Linux内核，从而实现微内核调用宏内核。这种实现方式可以有效地降低功耗，从而实现性能的提升。因此，我们小组计划在实现了FreeRTOS的内存管理单元之后，再实现FreeRTOS模块化方式调度Linux的功能。



然后，我们将把FreeRTOS移植到树莓派上，并进行性能的测试。



## 项目背景



### FreeRTOS

![image-20220405213253351](.\pics\image-20220405213253351.png)



#### 简介：



FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要。



由于RTOS需占用一定的系统资源(尤其是RAM资源)，只有μC/OS-II、embOS、salvo、FreeRTOS等少数实时操作系统能在小RAM单片机上运行。相对μC/OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行。



#### 特点：



用户可配置内核功能

多平台的支持

提供一个高层次的信任代码的完整性

目标代码小，简单易用

遵循MISRA-C标准的编程规范

强大的执行跟踪功能

堆栈溢出检测

没有限制的任务数量

没有限制的任务优先级

多个任务可以分配相同的优先权

队列，二进制信号量，计数信号灯和递归通信和同步的任务

优先级继承

免费开源的源代码



![image-20220405213348783](.\pics\image-20220405213348783.png)



#### 系统功能：



作为一个轻量级的操作系统，FreeRTOS提供的功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能等，可基本满足较小系统的需要。FreeRTOS内核支持优先级调度算法，每个任务可根据重要程度的不同被赋予一定的优先级，CPU总是让处于就绪态的、优先级最高的任务先运行。FreeRTOS内核同时支持轮换调度算法，系统允许不同的任务使用相同的优先级，在没有更高优先级任务就绪的情况下，同一优先级的任务共享CPU的使用时间。



FreeRTOS的内核可根据用户需要设置为可剥夺型内核或不可剥夺型内核。当FreeRTOS被设置为可剥夺型内核时，处于就绪态的高优先级任务能剥夺低优先级任务的CPU使用权，这样可保证系统满足实时性的要求；当FreeRTOS被设置为不可剥夺型内核时，处于就绪态的高优先级任务只有等当前运行任务主动释放CPU的使用权后才能获得运行，这样可提高CPU的运行效率。



#### 前景：



在嵌入式领域，FreeRTOS是不多的同时具有实时性，开源性，可靠性，易用性，多平台支持等特点的嵌入式操作系统。目前，FreeRTOS已经发展到支持包含X86，Xilinx，Altera等多达30种的硬件平台，其广阔的应用前景已经越来越受到业内人士的瞩目。



### 内存管理单元（MMU）



桌面系统的微处理器大多带有存储管理单元（MMU）， 所以桌面操作系统大都使用虚拟存储器，实际存储器和程序都被分成大小相同的页面，程序运行时，只将要运行的部分页面载 入内存即可。 MMU的作用是将虚地址映射为物理地址，保护地址越界。 大多数嵌入式系统的处理器没有MMU，即使系统中含有这些硬件也没采用，因此不能使用虚拟存管理技术，只能采用实存管理，直接访问实际的物理地址。 每个任务运行前，必须为它分配足够的连续地址空间，运行时全部载入嵌入式操作系统没有内存保护，所有任务共享一个运行空间，任何 一个任务都可能破坏其它任务的代码、数据或堆栈，甚至破坏内核代码或数据结构，导致整个系统工作异常，或使系统崩溃。 由此可见，开发嵌入式系统时， 内存管理非常重要。内存如何分配和释放，才能保证内存碎片少，且不会导致内存丢失 ，每个任务的堆栈如何安排，如何保证不侵犯其它程序包括系统程序和数据的地址空间，才能保证程序不会破坏系统或其它程序的正常工作，这些都是内存管理所要考虑的问题

 

内存管理模块管理系统的内存资源，它是操作系统的核心模块之一。主要包括内存的初始化、分配以及释放。

嵌入式系统不同于一般的桌面系统，对内存分配有如下要求： 

①快速性： 嵌入式系统对实时性的保证，要求简单、快速地分配内存。在嵌入式系统中，不可能采用通用操作系统中复杂而完善的内存分配策略。 

②可靠性：内存分配的请求必须得到满足，如果分配失败可能会带来灾难性的后果。 

③高效性：嵌入式系统中内存是有限、昂贵的资源，内存分配要尽可能地少浪费。



### 操作系统对内存管理

一、 为什么叫内存的抽象？

​	如果看过设计模式的人可能会知道，设计模式中提到最多的概念之一就是抽象，纯虚的基类作为接口就是对各种派生类对象的抽象。调用接口的用户，并不知道内部如何实现，因此内部实现的方法可能也有多种。地址空间也可以这样理解，32位机上，创建进程时操作系统为进程分配4GB的独立地址空间，用户可以使用这4GB的独立地址空间。但是，反过来一想，给每个进程都分配4GB地址空间，对于8GB内存的计算机而言岂不也就能同时运行两个进程。对于现代计算机而言，这显然是不可能的。所以实际上，用户能使用的4GB地址空间并不是对应物理内存的4GB，具体怎么实现被封装了，所以叫内存抽象。

二、 多道程序实现

​	现代操作系统能够同时运行多个程序，程序被运行时，需要占用内存的一块空间，如果同时运行的程序太多，物理内存装不下了怎么办？因此出现了两种技术，交换技术和虚拟内存。

三、 交换技术

​	交换技术：就是指当内存满了以后，就将一个程序从内存换出，将另一个程序放入内存，换出的内存数据保存在硬盘上，当该程序再次被换入的时候，就将硬盘上的数据拷贝到内存。

​	如下图，蓝色区域表示空闲的内存，绿色区域表示被某个进程占用的内存。刚开始装入A进程，然后装入B进程，再装入C进程。对于进程B而言假设其地址空间为0x0000-0xFFFF，对于其地址0x0000而言，对应的物理地址肯定不是0x0000，那应该是进程A的首地址。所以如果进程B要访问其首地址0x0000，就必须加上一个偏移量，而这样偏移量保存在一个基址寄存器中，除了基址寄存器还有一个界限寄存器防止访问越界。

​	再接着上面的说，如果这时候来了一个进程D，剩余的内存放不下进程D了，这时候可以选择将进程B交换出去，将进程B的数据保存到硬盘上，将进程D装入内存运行，如果CPU重新调度到进程B然后再采用同样的方式将某个进程交换出去，保存到硬盘上，把进程B装入内存中，这样的过程就叫交换技术。

![img](.\pics\wpsC5A.tmp.jpg) 

四、 虚拟内存

​	交换技术似乎解决了多道程序运行的问题，但是实际上如果每次交换一整个进程的数据，CPU需要花费数秒的时间来处理，这显然是不能被容忍的。因此，需要提出虚拟内存的概念。

​	虚拟内存：操作系统为了管理内存，给每个进程都分配独立的地址空间，对32位的系统而言，这个空间的大小是4GB。这4GB并不是实际的物理内存，实际上并不存在，因此有虚拟内存这一名称。

​	虚拟地址空间的地址称为逻辑地址，实际物理内存(就是内存条的大小)的地址空间称为物理地址。虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框。虚拟地址的页面通过一个页表映射物理内存的页框，页表中保存着两者的对应关系。逻辑地址是CPU使用的地址，当进程要访问该进程地址空间里的某个地址时时候，将该地址的值传递给CPU，CPU访问该地址时，会经过MMU将逻辑地址转换为物理地址，之前说的页表就保存在MMU中，操作系统为每个进程都维护一个页表。

​	说了这么多，我们还是不清楚为什么用虚拟内存就能实现多个程序同时运行，并且切换性能很高呢？

​	我们刚刚讲了，MMU把虚拟地址空间的页表和物理地址空间的页框关联起来了，如果页表中所有的数据都在页框中有对应项，那虚拟地址就没有任何意义了。实际上，程序运行的时候只需要部分数据存在内存中就可以了，因此只有部分页面和页框有对应值，其余的页表的数据保存在硬盘一块固定的地方(在Linux里叫swap分区，window里保存在C盘里)。当访问到某个页面在物理内存中没有对应的页框时就会发生缺页中断，这时候操作系统就将该页面保存在硬盘中的数据拷贝到物理内存中，并更新页表建立该页面和对应页框之间的映射关系。

​	这样做就实现了每次交换的代价很小，但是物理地址空间还是可能不够用，因此操作系统交换一些数据进物理内存的时候，也会从物理内存中移除部分页框数据到硬盘上，那到底该移出谁呢？这就涉及到页面交换算法了。

五、 Linux内存管理

​	前面讲了进程具有独立的地址空间，对于32位的系统而言，该地址空间的大小是4GB。Linux将这4GB的地址空间分为两部分，一个是用户地址空间，一个是内核地址空间。内核地址空间的地址范围范围为3G到4G，用户地址空间的地址范围为0G到3G。这里所讲的0G到4G都是虚拟地址，也称为逻辑地址。

​	Linux对内核空间和用户空间是分别管理的，因为进程要么运行在用户态，要么运行在内核态，进程通过系统调用陷入内核态。

六、 内核空间

​	内核空间的逻辑地址范围在3GB到4GB，并且内核空间是线性映射到物理空间的。何为线性映射，举例说明，内核空间逻辑地址0xc0000000对应的物理地址是0x00000000，逻辑地址0xc0000001对应的物理地址是0x00000001，也就是说逻辑地址到物理都减了一个0xc0000000的偏移量。如果1GB都是这样映射的话，那么内核空间能使用物理地址范围在0x00000000到0x40000000之间，不能访问所有的物理地址了。

​	为了解决这个问题，内核空间就将物理内存分为三个区：ZONE_DMA，ZONE_NORMAL，ZONE_HIHGEM。DMA区是用于一些特殊设备的，我们不过多追究。主要讨论高端内存(ZONE_HIHGEM)，对于内核空间而言高于896M的空间称为高端内存，低于896M的自然就可以称为低端内存了，低端内存的范围上，逻辑地址与物理地址是线性映射的。对于内核空间896M以上剩余的128M是用来访问高端内存的。这128M里的页面到物理页框随机映射的，和用户空间的映射是一样的。低端内存是自动永久映射的，高端内存可以永久映射也可以零时映射。

​	前面两端主要将的是对页表页框的管理，后面再将如何分配内存，也就是如果内核需要一定大小的内存的时，在3GB到4GB的范围里取出拿一块给它。内核空间分配内存可以按页分配，采用alloc_pages()和free_pages()函数分配多个连续页大小的内存，也可以通过kmalloc()分配指定大小的内存。

​	内核分配内存时很多时候都是分配固定大小的内存块，比如为每一个进程维护的task_struct结构体等。频繁分配这样的小块，很容易造成内存碎片，自然想到用内存池的方法来解决内存碎片的问题，只不过在Linux中给其取了一个更高大上的名字，叫高速缓存cache与slab层。一个高速缓存中有多个slab，分为三类：满的，部分满，和空的。每个slab就是一个链表，链表的每个节点就是一块固定大小的内存。和内存池是一样的。

七、 用户空间

看过操作系统书的人肯定看到过下面这样图。

![img](.\pics\wpsC5B.tmp.jpg) 

​	这张图解释了，一个进程将数据分为代码段，数据段，BSS段，堆和栈。实际上这些数据分享了0GB到3GB的地址范围。Linux管理这些段采用分区的结构，为每一个段维护一个vm_area_struct的结构体。这些结构体中保存了指向下一个指针因此形成了链表，还有另外一个指针使其构成红黑树，用户快速查找。

​	对于用户空间不得不谈到malloc函数，malloc函数是动态分配内存，内存来自用户空间的堆区。操作系统通过链表的形式将堆区的空间贯穿起来，当需要动态分配内存时就去查询该链表，找到空闲块，如果堆区满了，就调用sbrk函数扩大堆的范围。

​	当分配内存时，操作系统去查询该链表，找到一块能容纳下的地方放进去，将剩余的返还给空闲表。如何找到这个容纳的地方有出现了多种算法：首次适配算法，第二次首次适配，最佳适配算法，最差适配算法。这四个算法你可以去细讲差别，首次适配第一次找到第一个大于需要的地址空间的块，每次都从表头开始找，第二次着从上次找到的位置开始找，最佳适配找一个和需要大小最接近比需要的大的，最差每次早最大的。实际上对于进程内部堆的分配，页可以采取同样类似的办法。具体可以去看malloc的源码。

​	另外还有一点很重要的是内存映射文件，内存映射文件通过mmap函数实现，将文件映射到内存中，读写文件通过操作指针就能实现。实际上，内存映射文件并不是调用mmap的时候就将该文件拷贝到内存中，而是建立逻辑地址到文件地址之间的映射关系，但访问这段内存的数据时还是引发缺页中断，然后将该页的数据换到物理地址上。可以直接使用mmap实现进程间内存共享，XSI的内存共享实现的原理也是基于mmap，只是映射一种特殊文件系统的文件到内存中，该文件不能通过read和write调用来访问。

![img](.\pics\wpsC5C.tmp.jpg) 



### 相关算法

从分配的内存是否连续，可以分为两大类。

1.连续内存管理：为进程分配的内存空间是连续的，但这种分配方式容易形成内存碎片（碎片是难以利用的空闲内存，通常是小内存），降低内存利用率。连续内存管理主要分为单一连续内存管理和分区式内存管理两种。

2.非连续内存管理：将进程分散到多个不连续的内存空间中，可以减少内存碎片，内存使用率更高。如果分配的基本单位是页，则称为分页内存管理；如果基本单位是段，则称为分段内存管理。

当前的操作系统，普遍采用非连续内存管理方式。不过因为分配粒度较大，对于内存较小的嵌入式系统，一般采用连续内存管理。

 

#### 连续内存管理



1. 单一连续存储管理：在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。故多采用分区式内存管理。

2. 分区式内存管理：分为固定分区和动态分区。

固定分区：事先就把内存划分为若干个固定大小的区域。分区大小既可以相等也可以不等。固定分区易于实现，但是会造成分区内碎片浪费，而且分区总数固定，限制了可以并发执行的进程数量。

动态分区：动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。



#### 动态内存分配

嵌入式系统的动态内存分配器有3个主要的性能需求:平均分配时间短, 最差情况下分配时间可预计, 内存碎片少。

 

#### 运作机制

动态分区管理一般采用空闲链表法，即基于一个双向链表来保存空闲分区。对于初始状态，整个内存块都会被作为一个大的空闲分区加入到空闲链表中。当进程申请内存时，将会从这个空闲链表中找到一个大小满足要求的空闲分区。如果分区大于所需内存，则从该分区中拆分出需求大小的内存交给进程，并将此拆分出的内存从空闲链表中移除，剩下的内存仍然是一个挂在空闲链表中的空闲分区。

 

#### 数据结构

空闲链表法有多种数据结构实现，这里介绍一种较为简单的数据结构。每个空闲分区的数据结构中包含分区的大小，以及指向前一个分区和后一个分区的指针，这样就能将各个空闲分区链接成一个双向链表。

![img](.\pics\wps54F2.tmp.jpg) 

近年来, 研究人员提出了多种动态内存管理算法, 大概分类如下: (1) 顺序查找算法; (2) Buddy算法 (伙伴算法) ; (3) 位图匹配算法, 使用位图来标记堆的使用情况; (4) TLSF匹配算法。

 

#### 主流算法

1. First Fit（首次适应算法）：

First Fit要求空闲分区链表以地址从小到大的顺序链接。分配内存时，从链表的第一个空闲分区开始查找，将最先能够满足要求的空闲分区分配给进程。

2. Next Fit（循环首次适应算法）：

Next Fit由First Fit算法演变而来。分配内存时，从上一次刚分配过的空闲分区的下一个开始查找，直至找到能满足要求的空闲分区。查找时会采用循环查找的方式，即如果直到链表最后一个空闲分区都不能满足要求，则返回到第一个空闲分区开始查找。

3. Best Fit（最佳适应算法）

从所有空闲分区中找出能满足要求的、且大小最小的空闲分区。为了加快查找速度，Best Fit算法会把所有空闲分区按其容量从小到大的顺序链接起来，这样第一次找到的满足大小要求的内存必然是最小的空闲分区。

4. Worst Fit（最坏适应算法）

从所有空闲分区中找出能满足要求的、且大小最大的空闲分区。Worst Fit算法按其容量从大到小的顺序链接所有空闲分区。

5. Two LevelSegregated Fit（TLSF）

使用两层链表来管理空闲内存，将空闲分区大小进行分类，每一类用一个空闲链表表示，其中的空闲内存大小都在某个特定值或者某个范围内。这样存在多个空闲链表，所以又用一个索引链表来管理这些空闲链表，该表的每一项都对应一种空闲链表，并记录该类空闲链表的表头指针。

![img](.\pics\wps54F3.tmp.jpg) 

图中，第一层链表将空闲内存块的大小根据2的幂进行分类。第二层链表是具体的每一类空闲内存块按照一定的范围进行线性分段。比如25这一类，以23即8分为4个内存区间【25，25+8），【25+8，25+16），【25+16，25+24），【25+24，25+32）；216这一类，以214分为4个小区间【216，216+214），【216+214，216+2*214），【216+2*214，216+3*214），【216+3*214，216+4*214）。同时为了快速检索到空闲块，每一层链表都有一个bitmap用于标记对应的链表中是否有空闲块，比如第一层bitmap后3位010，表示25这一类内存区间有空闲块。对应的第二层bitmap为0100表示【25+16，25+24）这个区间有空闲块，即下面的52Byte。

6. Buddysystems（伙伴算法）

Segregated Fit算法的变种，具有更好的内存拆分和回收合并效率。伙伴算法有很多种类，比如BinaryBuddies，Fibonacci Buddies等。Binary Buddies是最简单也是最流行的一种，将所有空闲分区根据分区的大小进行分类，每一类都是具有相同大小的空闲分区的集合，使用一个空闲双向链表表示。BinaryBuddies中所有的内存分区都是2的幂次方。

![img](.\pics\wps54F4.tmp.jpg) 

因为无论是已分配的或是空闲的分区，其大小均为 2 的幂次方，即使进程申请的内存小于分配给它的内存块，多余的内存也不会再拆分出来给其他进程使用，这样就容易造成内部碎片。

 

当进程申请一块大小为n的内存时的分配步骤为：

1、计算一个i值，使得2i-1<n≤2i

2、在空闲分区大小为2i的空闲链表中查找

3、如果找到空闲块，则分配给进程

4、如果2i的空闲分区已经耗尽，则在分区大小为2i+1的空闲链表中查找

5、如果存在2i+1的空闲分区，则将此空闲块分为相等的两个分区，这两分区就是一对伙伴，其中一块分配给进程，另一块挂到分区大小为2i的空闲链表中

6、如果2i+1的空闲分区还是不存在，则继续查找大小为2i+2的空闲分区。如果找到，需要进行两次拆分。第一次拆分为两块大小为2i+1的分区，一块分区挂到大小为2i+1的空闲链表中，另一块分区继续拆分为两块大小为2i的空闲分区，一块分配给进程，另一块挂到大小为2i的空闲链表中

7、如果2i+2的空闲分区也找不到，则继续查找2i+3，以此类推

在内存回收时，如果待回收的内存块与空闲链表中的一块内存互为伙伴，则将它们合并为一块更大的内存块，如果合并后的内存块在空闲链表中还有伙伴，则继续合并到不能合并为止，并将合并后的内存块挂到对应的空闲链表中。

 

| 内存算法      | 优点                                                     | 缺点                                                         |
| ------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| First Fit     | 高地址空间大空闲块被保留                                 | 低地址空间被不断拆分，造成碎片；每次都从第一个空闲分区开始查找，增加了查找时的系统开销 |
| Next Fit      | 空闲分区分布比较均匀，算法开销小                         | 缺乏大内存空闲块                                             |
| Best Fit      | 用最小内存满足要求，保留大内存空闲块                     | 每次分配后所拆分出来的剩余空闲内存总是最小的，造成许多小碎片，算法开销大 |
| Worst Fit     | 每次分配后所拆分出来的剩余空闲内存仍较大，减少小碎片产生 | 缺乏大内存空闲块，算法开销大                                 |
| TLSF          | 查找效率高，时间复杂度小，碎片问题表现良好               | 内存回收时算法复杂，系统开销大                               |
| Buddy systems | 内部碎片比较严重                                         | 外部碎片较少                                                 |

 

#### 内存碎片化处理

比较几种不同的算法可知内存碎片是难以完全避免的，因此我们需要相关的技术来处理内存碎片。

内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。这种技术在提供了某种程度上的灵活性的同时，也存在着一些弊端，例如：对占用分区进行内存数据搬移占用CPU时间；如果对占用分区中的程序进行“浮动”，则其重定位需要硬件支持。

 

紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时。

![img](.\pics\wps5505.tmp.jpg) 

堆结构的存储管理的分配算法：

在动态存储过程中，不管哪个时刻，可利用空间都是一个地址连续的存储区，在编译程序中称之为"堆"，每次分配都是从这个可利用空间中划出一块。其实现办法是：设立一个指針，称之为堆指针，始终指向堆的最低（或锻联）地址。当用户申请N个单位的存储块时，堆指针向高地址（或 低地址）称动N个存储单位，而移动之前的堆指针的值就是分配给用户的占用块的初始地址。例如，某个串处理系统中有A、B、C、D这4个串，其串值长度分别為12,6,10和8. 假设堆指针free的初值为零，则分配给这4个串值的存储空间的初始地址分别为0.12.18和 28,如图8.12(a)和（b)所示，分配后的堆指针的值为36。 因此，这种堆结构的存储管理的分配算法非常简单。

释放内存空间执行内存紧缩：

  回收用户释放的空闲块就比较麻烦.由于系统的可利用空间始终是一个绝址连续的存储块，因此回收时必须将所释放的空间块合并到整个堆上去才 能重新使用，这就是"存储策缩"的任务.通常，有两种做法：

  一种是一旦有用户释放存储块即进行回收紧缩，例始，图 (a)的堆，在c串释放存储块时即回收紧缩，例如图 (c)的堆，同时修改串的存储映像成图(d)的状态；

  另一种是在程序执行过程中不回收用户随时释放的存储块，直到可利用空同不够分配或堆指针指向最高地址时才进行存储紧缩。此时紧缩的目的是将堆中所有的空间块连成一块，即将所有的占用块部集中到 可利用空间的低地地区，而剩余的高地址区成为一整个地继连续的空闲块，如下图所示，其中（a）为紧缩前的状态，(b)为紧缩后的状态。

![img](.\pics\wps5506.tmp.jpg) 

​           a 紧缩前 b紧缩后

 

  和无用单元收集类似，为实现存储紫编,首先要对占用块进行“标志”，标志算法和无用单元收集类同(存储块的结构可能不同）,其次需进行下列4步操作：

 （1)计算占用块的新地址。从最低地址开始巡査整个存储空间，对每一个占用块找到它在紧缩后的新地址。 为此,需设立两个指针随巡查向前移动,这两个指针分别指示占用 块在紧缩之前和之后的原地址和新地址。因此,在每个占用块的第-·个存储单位中，除了 设立长度域(存储该占用换的大小）和标志域(存储区别该存储块是占用块或空闲块的标 志）之外，还需设立一个新地址城，以存储占用块在紧缩后应有的新地址，即建立一张新， 旧地址的对照表。

 (2)修改用户触初始变量表，以便在存储紧缩后用户程序能继续正常运行。

 (3)检查每个占用块中存储的数据，若有指向其他存储换的指针，则需作相应修改.

 (4)将所有占用块迁移到新地址走，这实质上是作传送数据的工作。

 至此，完成了存储紧缩的操作，最后,将堆指针赋以新值（即紧缩后的空闲存储区的最低地址）。

  可见,存储紧缩法比无用单元收集法更为复杂，前者不仅要传送数据（进行占用块迁移），而且还有需要修改所有占用块中的指针值。因此，存储紧缩也是个系统操作，且非不得已就不用。



### Rust编程语言

Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的程序设计风格。

![image-20220405213431098](.\pics\image-20220405213431098.png)



#### rust优点：

##### 高性能

Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。

##### 可靠性

Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让程序员在编译期就能够消除各种各样的错误。

##### 生产力

Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。



### 树莓派

树莓派（英语：Raspberry Pi）英国树莓派基金会开发的微型单板计算机，目的是以低价硬件及自由软件促进学校的基本计算机科学教育。

![image-20220405213528585](.\pics\image-20220405213528585.png)

树莓派系列计算机每一代均使用博通（Broadcom）出产的ARM架构处理器，如今生产的机型（树莓派4B）内存在2GB和8GB之间，主要TF卡作为系统存储媒体（初代使用SD卡），配备USB接口和HDMI的视频输出（支持声音输出），内置Ethernet/WLAN/Bluetooth网络链接的方式（依据型号决定），并且可使用多种操作系统。产品线型号分为A型、B型、Zero型和ComputeModule计算卡。

### RT-Linux

RTLinux（AReal-Time Linux,亦称作实时Linux）是Linux中的一种实时操作系统。它由新墨西哥矿业及科技学院的V. Yodaiken开发。RTLinux有一个由社区支持的免费版本，称为RTLinux Free，以及一个来自FSMLabs的商业版本，称作RTLinux Pro。

RT-Linux已经成功地应用于航天飞机的空间数据采集、科学仪器测控和电影特技图像处理等广泛领域，在电信、工业自动化和航空航天等实时领域也有成熟应用。随着信息技术的飞速发展，实时系统已经渗透到日常生活的各个层面，包括传统的数控领域、军事、制造业和通信业，甚至连潜力巨大的信息家电、媒体广播系统和数字影像设备都对实时性提出了愈来愈高的要求。

RT-Linux开发者并没有针对实时操作系统的特性而重写Linux的内核，因为这样做的工作量非常大，而且要保证兼容性也非常困难。将linux的内核代码做一些修改，将linux本身的任务以及linux内核本身作为一个优先级很低的任务，而实时任务作为优先级最高的任务。即在实时任务存在的情况下运行实时任务，否则才运行linux本身的任务。RT-Linux能够创建精确运行的符合POSIX.1b标准的实时进程；并且作为一种遵循GPL v2协议的开放软件，可以达GPL v2协议许可范围内自由地、免费地使用、修改和再发生。

它是Linux在实时性方面的扩展，采用已获得专利的双核技术:一个微型的RTLinux内核把原始的Linux内核作为它在空闲时的一个线程来运行。这开启了在两个不同的内核层面上――实时的RTLinux内核和常用的，非实时的Linux内核――运行不同程序的新方式。原始的Linux内核通过RTLinux内核访问硬件。这样，所有硬件实际上都是由RTLinux来进行管理的。有两种不同的RTLinux版本：RTLinux/Free(或者RTLinux/Open)和RTLinux/Pro. RTLinux/Pro是一个由FSMLabs开发的完全商业版本的实时linux。RTLinux/Free是一个由社区开发的开源版本。

现有的Linux是一个通用的操作系统，虽然它采用了许多技术来提高系统的运行和反应速度，但它本质上不是一个实时操作系统，应用于嵌入式环境中还存在诸多的不足。具体表现如下：

### 关中断问题

在系统调用中，为了保护临界区资源，Linux处于内核临界区时，中断会被系统屏蔽，这就意味着如果当前进程正处于临界区，即使它的优先级较低，也会延迟高优先级的中断请求。在实时应用中，这是一个十分严重的问题。

### 进程调度问题

Linux采用标准的UNIX技术使得内核是不可抢占的。采用基于固定时间片的可变优先级调度，不论进程的优先级多么低，Linux总会在某个时候分给该进程一个时间片运行，即使同时有可以运行的高优先级进程，它也必须等待低优先级进程的时间片用完，这对一些要求高优先级进程立即抢占CPU的实时应用是不能满足要求的。

### 时钟问题

Linux为了提高系统的平均吞吐率，将时钟中断的最小间隔设置为10ms，这对于一个周期性的实时任务，间隔要求小于10ms时，就不能满足实时任务的需要。如果要把时钟 的间隔改小以满足周期性的实时任务的需要，由于Linux的进程切换比较费时，时钟中断越频繁，而花在中断处理上的时间就越多,系统的大部分时间是调用进程调度程序进行进程调度而不能进行正常的处理。

**RTLinux的特点**

在Linux 操作系统中，调度算法（基于最大吞吐量准则）、设备驱动、不可中断的系统调用、中断屏蔽以及虚拟内存的使用等因素，都会导致系统在时间上的不可预测性，决定了Linux操作系统不能处理硬实时任务。RTLinux为避免这些问题，在Linux内核与硬件之间增加了一个虚拟层（通常称作虚拟机），构筑了一个小的、时间上可预测的、与Linux内核分开的实时内核，使得在其中运行的实时进程满足硬实时性。并且RTLinux和Linux构成一个完备的整体，能够完成既包括实时部分又包括非实时部分的复杂任务。

### 实现机理

RT-Linux对Linux内核进行改造，将Linux内核工作环境做了一些变化，如图1所示：

![image-20220406221513957](.\pics\image-20220406221513957.png)

​																		图1 RTLinux对Linux内核改变

RTLinux有两种中断：硬中断和软中断。软中断是常规Linux内核中断。它的优点在于可无限制地使用Linux内核调用。硬中断是安装实时Linux的前提。依赖于不同的系统，实时Linux下硬中断的延迟是15μs。

![image-20220406221553406](.\pics\image-20220406221553406.png)

​																				图2 RTLinux的体系结构

RTLinux的体系结构如图2所示。RTLinux的设计思想是:应用硬件的实时约束将实时程序分割成短小简单的部分,较大部分承担较复杂的任务。根据这一原则,将应用程序分为硬实时和软实时（即程序）2个部分。

**硬实时的实现：**

![image-20220406221703239](.\pics\image-20220406221703239.png)

​																				图3 RT-FIFO结构图

图3所示的是RTFIFO结构图。RTLinux将标准Linux内核作为简单实时操作系统（RTOS）（或叫子内核）里优先权最低的线程来运行，从而避开了Linux内核性能的问题。 从图3可以看出，RTLinux拥有两个内核。这就意味着有两组单独的API，一个用于Linux环境，另一个用于实时环境。此外，为保证实时进程与非实时Linux进程不顺序进行数据交换，RTLinux引入了RT-FIFO队列。RT-FIFO被Linux视为字符设备，最多可达150个，分别命名为/dev/rtf0、/dev/rtf1……/dev/rtf63。最大的RT-FIFO数量在系统内核编译时设定。

RTLinux程序运行于用户空间和内核态两个空间。RTLinux提供了应用程序接口。借助这些API函数将实时处理部分编写成内核模块，并装载到RTLinux内核中，运行于RTLinux的内核态。非实时部分的应用程序则在Linux下的用户空间中执行。这样可以发挥Linux对网络和数据库的强大支持功能。

**软实时的实现:**

RTLinux通过一个高效的、可抢先的实时调度核心来全面接管中断，并把Linux作为此实时核心的一个优先级最低的进程运行。当有实时任务需要处理时，RTLinux运行实时任务；无实时任务时，RTLinux运行Linux的非实时进程。其系统结构见图4。

RTLinux在默认的情况下采用优先级的调度策略，即系统调度器根据各个实时任务的优先级来确定执行的先后次序。优先级高的先执行，优先级低的后执行，这样就保证了实时进程的迅速调度。同时RTLinux也支持其它的调度策略，如最短时限最先调度（EDP）、确定周期调度（RM）（周期段的实时任务具有高的优先级）。RTLinux将任务调度器本身设计成一个可装载的内核模块，用户可以根据自己的实际需要，编写适合自己的调度算法。

![image-20220406221836888](.\pics\image-20220406221836888.png)

​																			图4 RTLinux系统结构图

对于一个操作系统而言，精确的定时机制虽然可以提高任务调度器的效率，但会增加CPU处理定时中断的时间开销。RTLinux对时间精度和时钟中断处理的时间开销进行了折中考虑。不是像Linux那样将8254定时器设计成10ms产生一次定时中断的固定模式，而是将定时器芯片设置为终端计时中断方式。根据最近的进程的时间需要，不断调整定时器的定时间隔。这样不仅可以获得高定时精度，同时中断处理的开销又最小。

## 立项依据

随着智能硬件、物联网行业的迅猛发展, 嵌入式系统在各个领域都得到了广泛的应用。嵌入式操作系统可以帮助嵌入式设备更好地完成任务的调度，从而更高效地完成任务。然而，一开始由于嵌入式设备内存较少，一些主流的嵌入式操作系统如FreeRTOS并没有内存管理单元。随着时代的发展，内存的成本越来越低，嵌入式设备也在向着内存增加的方向发展。所以，按照当前的趋势，嵌入式操作系统也应该有自己的内存管理单元。嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。于是，我们小组决定为FreeRTOS编写一个内存管理单元，从而让其有更强大的任务调度能力。由于Rust是一门高效而且安全的语句，我们将使用Rust来进行编写。

嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。因此，我们组的题目是十分符合现实趋势的。

微内核的模块化使用也是一个十分高效的内核实现方式，它可以大大降低功耗，而这在操作系统的应用中无疑是非常理想的。而内核的模块化挂载也是一种完全可行的实现方式。所以，我们组使用微内核调用宏内核的路线是实用而且可行的。

 

## 重要性分析



### 为FreeRTOS添加MMU：

当今的嵌入式设备内存在不断扩大。

![image-20220406222205134](.\pics\image-20220406222205134.png)



CPU:全志R16，主频高达1.2GHZ
内存：DDR3/DDR3L 1G,可扩展至2G
存储：4GB EMMC,可兼容至64GB
供电电压：5V
尺寸：42.4mm x 45.4mm
工作温度：0° c~80℃
存储温度：-40° C~100° C



以上为一个扫地机器人的参数，可以看出扫地机器人已经拥有1G的内存。

![image-20220406173626271](.\pics\image-20220406173626271.png)



产品型号 InBio510
核心板 ZMM220EMC核心板（128M内存，FLASH为256M）

上图为InBio5系列门禁控制器，是一款区域型门禁系统。可以看出，它的内存也有128M

从上面两个例子可以看出，目前嵌入式系统的内存已经比较大了，所以嵌入式操作系统也需要有合适的内存管理单元。

现代操作系统普遍采用虚拟内存机制，这需要处理器中的MMU（Memory Management Unit，内存管理单元）提供支持，下面简要介绍MMU的作用。

首先引入两个概念，虚拟地址和物理地址。如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA）。如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA。

如果是32位处理器，则内地址总线是32位的，与CPU执行单元相连（图中只是示意性地画了4条地址线），而经过MMU转换之后的外地址总线则不一定是32 位的。也就是说，虚拟地址空间和物理地址空间是独立的，32位处理器的虚拟地址空间是4GB，而物理地址空间既可以大于也可以小于4GB。

MMU除了做地址转换之外，还提供内存保护机制。各种体系结构都有用户模式（User Mode）和特权模式（Privileged Mode）之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在CPU处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，访问权限又分为可读、可写和可执行三种。这样设定好之后，当CPU要访问一个VA时，MMU会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成PA，否则不允许访问，产生一个异常（Exception）。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由CPU内部产生，中断产生的原因和CPU当前执行的指令无关，而异常的产生就是由于CPU当前执行的指令出了问题，例如访问内存的指令被MMU检查出权限错误，除法指令的除数为0等都会产生异常。

通常操作系统把虚拟地址空间划分为用户空间和内核空间，例如x86平台的Linux系统虚拟地址空间是0x00000000~0xffffffff，前 3GB（0x00000000~0xbfffffff）是用户空间，后1GB（0xc0000000~0xffffffff）是内核空间。用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。这样可以保护内核，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性。CPU在产生中断或异常时不仅会跳转到中断或异常服务程序，还会自动切换模式，从用户模式切换到特权模式，因此从中断或异常服务程序可以跳转到内核代码中执行。事实上，整个内核就是由各种中断和异常处理程序组成的。总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。



综上，MMU是十分重要的，它可以为操作系统内存调度提供很大方便，而且可以让内存访问更加安全。

目前，嵌入式操作系统多种多样，使用于许多不同场合。

嵌入式中有一部分是通过对Linux的改进来实现实时性。

inux是分时系统，不过可以通过配置内核改成实时。
嵌入式Linux 系统是在原来Linux的发行版本之上进行了优化和改进的，用于嵌入式的移动终端等设备的嵌入式Linux系统现在基本上都是实时性较高的，但有些LiNUX系统还是分时系统。

实时操作系统（RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系 统作出快速响应，并控制所有实时任务协调一致运行的操作系统。因而，提供及时响应和高可靠性是其主要特点。实时操作系统有硬实时和软实时之分，硬实时要求 在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可。我们通常使用的操作系统在经过一定改 变之后就可以变成实时操作系统。
实时操作系统是保证在一定时间限制内完成特定功能的操作系统。例如，可以为确保生产线上的机器人能获取某个物 体而设计一个操作系统。在“硬”实时操作系统中，如果不能在允许时间内完成使物体可达的计算，操作系统将因错误结束。在“软”实时操作系统中，生产线仍然 能继续工作，但产品的输出会因产品不能在允许时间内到达而减慢，这使机器人有短暂的不生产现象。一些实时操作系统是为特定的应用设计的，另一些是通用的。 一些通用目的的操作系统称自己为实时操作系统。但某种程度上，大部分通用目的的操作系统，如微软的Windows NT或IBM的OS/390有实时系统的特征。这就是说，即使一个操作系统不是严格的实时系统，它们也能解决一部分实时应用问题。

任务调度策略是直接影响实时性能的因素。尽管调度算法多种多样，但大多由单调率算法(RM)和最早期限优先算法(EDF)变化而来。前者主要用 于静态周期任务的调度，后者主要用于动态调度，在不同的系统状态下两种算法各有优劣。在商业产品中采用的实际策略常常是各种因素的折中。
　　QNX 提供POSIX.1b标准进程调度：
　　32个进程优先级；
　　抢占式的、基于优先级的正文切换；
　　可选调度策略：FIFO、轮转策略、适应性策略。
　　LynxOS 其调度策略为：
　　LynxOS支持线程概念，提供256个全局用户线程优先级；
　　硬实时优先级调度：在每个优先级上实现了轮转调度、定量调度和FIFO调度策略；
　　快速正文切换和阻塞时间短；
　　抢占式的RTOS核心。
　　RT－Linux
　　在操作系统之下实现了一个简单的实时核心，Linux本身作为一个可抢占的任务在核内运行，优先级最低，随时会被高优先级任务抢占。
　　用户可自行编写调度程序，它们可实现为可加载的核心模块；
　　已实现的调度程序有：基于优先级的抢占式调度和EDF调度；
　　基于优先级的调度使用”单调率算法”，它直接支持周期任务。
　　KURT－Linux
　　可运行在两种状态之下：通常状态和实时状态。在通常状态下，所有进程都可以运行，但某些核心服务将带来中断屏蔽的不可预期性。实时模式只允许实时进程运行。
　　支持FIFO调度策略、轮转调度策略和UNIX分时调度策略；
　　增加了SCHED－KURT调度策略，这是一种静态调度策略，使用一个特殊的调度文件记录预先定义好的待调度进程的参数。
　　从以上简略描述可以看出，前三种调度策略实现较规范，特别是两种商业RTOS，遵循或部分遵循POSIX.1b实时调度标准。

下面来说说FreeRTOS的优点。

FreeRTOS的设计小巧且简易，整个核心代码只有3到4个C文件，为了让代码容易阅读、移植和维护，大部分的代码都是以C语言编写，只有一些函数（多数是架构特定排班副程序）采用汇编语言编写。

FreeRTOS提供许多方法以实现多线程（threads）、多作业（task）、互斥锁（mutex）、信号量（semaphore）和软件计时器（software timer），有个为低耗电应用程序提供的无嘀嗒（tick-less）模式，线程的优先权管理也有支持，此外，FreeRTOS提供了四种存储器配置的模式：

FreeRTOS中没有一些像Linux、Microsoft Windows等典型操作系统具有的先进特征，例如设备驱动程序、先进存储器管理机制、用户管理和网络管理，FreeRTOS着重在执行的简洁与速度，FreeRTOS有时会被视为是一个‘线程库’而非‘操作系统’，尽管可以找到命令行接口和类似POSIX I/O 接口的插件。

FreeRTOS实现了多线程，主程序会在规律的短时间区间内调用一个线程时计方法，这个方法会以循环制依照任务的优先级进行任务切换，一般来说，这个短时间区间介于 1/1000 秒与 1/100 秒之间，透过一个硬件时计中断来计时，但这个区间经常随着特定的应用而改变。

从FreeRTOS官网（FreeRTOS.org（页面存档备份，存于互联网档案馆））所下载到的代码包含准备用来移植或编译的配置文件和演示代码，让用户可以快速地进行应用程序设计。

综上，FreeRTOS是一个发展前景很好的嵌入式操作系统，我们对它的改进也是十分重要的。

Linux内核相对于FreeRTOS由于实现比较复杂，其功耗也相对较高，但它的功能也相对较为完善。而如果能把FreeRTOS作为微内核，在操作系统之下实现一个简单的实时核心，Linux本身作为一个可抢占的任务在核内运行，优先级最低，随时会被高优先级任务抢占。用户可自行编写调度程序，它们可实现为可加载的核心模块。这样就可以实现能耗和功能的权衡。

##  相关工作

1. 基于Ramakrishna提出的smart DM allocator的改进 ，动态内存管理中利用统计数据来提高内存管理性能，通过基于过去数据的启发式算法来预测某个大小内存块的生命期长短, 根据预测结果在相应的内存区进行分配, 其中生命期短的内存块即为频繁申请释放的内存块。

2. 对可生存嵌入式系统内存管理设计与实现：可生存性是指系统在受到来自外部或内部的破坏时，在一部分任务产生故障、错误或失效的情况下，能及时采取措施，保证关键任务及时完成的能力。这种能力对嵌入式系统特别是安全关键嵌入式系统显得尤其重要。与其它系统相比，嵌入式系统对成本、功耗、体积等有严格限制，采用增加硬件部件来提高系统可生存性的方法将增加系统的成本，功耗等。采用改进软件系统来提高系统可生存性成为一种理想的方法。改进内存管理来提高对嵌入式系统生存性的支持作用是一种可行方案。

3. 针对工业物联网高速通信中出现流量堵塞如何高效存储的问题，引入内存管理的方法。

4. 基于TLSF算法改进的动态内存管理算法，提升内存分配效率,同时通过增加校验,可以检测系统中可能存在的内存泄漏问题,提升系统稳定性

5. 基于线段树的高效内存管理方法。现有的内存管理的工作多集中在内存分配的效率上,实时性较好,但易产生内存碎片。而该方法将内存地址空间划分为内存段,建立内存管理线段树,基于所建立的内存管理线段树,进行高效灵活的内存分配和回收管理,减少了内存碎片的产生。另外,针对线段树空间开销大的问题,提出了线段树空间优化的方法。

6. 多kernel操作系统的已有实现方法

    

   实现1：

   ​	多核双Kernel，两个OS分别运行在自己的核上，两者通过共享内存进行系统间通讯

   ​	某种意义上是一种分布式

   

   ![image-20220406222711233](.\pics\image-20220406222711233.png)

    

   实现2：

   ​	单核双Kernel，将其中一个OS嵌入另一个OS，共同吸收两者优点

   ​	目前已有的实现：VxWIN，其将xWorks系统嵌入windows系统，能够在windows下使用xWorks达到部分的高实时性

    

   ![image-20220406222724783](.\pics\image-20220406222724783.png) 

   ![image-20220406222755240](.\pics\image-20220406222755240.png) 

## 参考文献



《嵌入式实时系统内存管理策略》

《嵌入式实时系统中动态内存管理算法的设计与实现》

《嵌入式系统新型动态内存管理机制的研究》

《可生存嵌入式 OS 内存管理设计与实现》

《工业物联网中的缓冲内存管理设计与实现》

《基于TLSF算法改进的动态内存管理算法研究》

《基于线段树的高效内存管理算法及其空间优化》

[VxWin White Paper JN 23058 - Kuka (yumpu.com)](https://www.yumpu.com/en/document/read/5333799/vxwin-white-paper-jn-23058-kuka)

[VxWin White Paper JN 23058 - Kuka (yumpu.com)](https://www.yumpu.com/en/document/read/5333799/vxwin-white-paper-jn-23058-kuka)

https://zh.wikipedia.org/zh-cn/FreeRTOS

https://baike.baidu.com/item/FreeRTOS

[树莓派 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/zh-cn/树莓派)

https://www.rust-lang.org/zh-CN/

[https://baike.baidu.com/item/Rust%E8%AF%AD%E8%A8%80/9502634](https://baike.baidu.com/item/Rust语言/9502634)

[操作系统内存管理(思维导图详解)_hguisu的博客-CSDN博客_内存管理](https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

[操作系统的内存管理算法_strongerHuang的博客-CSDN博客](https://blog.csdn.net/ybhuangfugui/article/details/107551847)

[嵌入式学习记录：内存管理单元（MMU）介绍_Linux编程_Linux公社-Linux系统门户网站 (linuxidc.com)](https://www.linuxidc.com/Linux/2011-09/43525.htm)





