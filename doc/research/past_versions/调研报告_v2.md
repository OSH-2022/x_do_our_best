# 调研报告

## 小组成员

* 陆子睦
* 黄与进
* 刘津畅
* 唐星
* 杨涛



## 项目简介



随着智能硬件、物联网行业的迅猛发展, 嵌入式系统在各个领域都得到了广泛的应用。嵌入式操作系统可以帮助嵌入式设备更好地完成任务的调度，从而更高效地完成任务。然而，一开始由于嵌入式设备内存较少，一些主流的嵌入式操作系统如FreeRTOS并没有内存管理单元。随着时代的发展，内存的成本越来越低，嵌入式设备也在向着内存增加的方向发展。所以，按照当前的趋势，嵌入式操作系统也应该有自己的内存管理单元。嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。于是，我们小组决定为FreeRTOS编写一个内存管理单元，从而让其有更强大的任务调度能力。由于Rust是一门高效而且安全的语句，我们将使用Rust来进行编写。



而有了内存管理单元之后，嵌入式内核就有可能去以模块化的形式去调用Linux内核，从而实现微内核调用宏内核。这种实现方式可以有效地降低功耗，从而实现性能的提升。因此，我们小组计划在实现了FreeRTOS的内存管理单元之后，再实现FreeRTOS模块化方式调度Linux的功能。



然后，我们将把FreeRTOS移植到树莓派上，并进行性能的测试。



## 项目背景



### FreeRTOS

![image-20220405213253351](D:/OSH大作业/调研报告/pics/image-20220405213253351.png)



#### 简介：



FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要。



由于RTOS需占用一定的系统资源(尤其是RAM资源)，只有μC/OS-II、embOS、salvo、FreeRTOS等少数实时操作系统能在小RAM单片机上运行。相对μC/OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行。



#### 特点：



用户可配置内核功能

多平台的支持

提供一个高层次的信任代码的完整性

目标代码小，简单易用

遵循MISRA-C标准的编程规范

强大的执行跟踪功能

堆栈溢出检测

没有限制的任务数量

没有限制的任务优先级

多个任务可以分配相同的优先权

队列，二进制信号量，计数信号灯和递归通信和同步的任务

优先级继承

免费开源的源代码



![image-20220405213348783](D:/OSH大作业/调研报告/pics/image-20220405213348783.png)



#### 系统功能：



作为一个轻量级的操作系统，FreeRTOS提供的功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能等，可基本满足较小系统的需要。FreeRTOS内核支持优先级调度算法，每个任务可根据重要程度的不同被赋予一定的优先级，CPU总是让处于就绪态的、优先级最高的任务先运行。FreeRTOS内核同时支持轮换调度算法，系统允许不同的任务使用相同的优先级，在没有更高优先级任务就绪的情况下，同一优先级的任务共享CPU的使用时间。



FreeRTOS的内核可根据用户需要设置为可剥夺型内核或不可剥夺型内核。当FreeRTOS被设置为可剥夺型内核时，处于就绪态的高优先级任务能剥夺低优先级任务的CPU使用权，这样可保证系统满足实时性的要求；当FreeRTOS被设置为不可剥夺型内核时，处于就绪态的高优先级任务只有等当前运行任务主动释放CPU的使用权后才能获得运行，这样可提高CPU的运行效率。



#### 前景：



在嵌入式领域，FreeRTOS是不多的同时具有实时性，开源性，可靠性，易用性，多平台支持等特点的嵌入式操作系统。目前，FreeRTOS已经发展到支持包含X86，Xilinx，Altera等多达30种的硬件平台，其广阔的应用前景已经越来越受到业内人士的瞩目。



### 内存管理单元（MMU）



桌面系统的微处理器大多带有存储管理单元（MMU）， 所以桌面操作系统大都使用虚拟存储器，实际存储器和程序都被分成大小相同的页面，程序运行时，只将要运行的部分页面载 入内存即可。 MMU的作用是将虚地址映射为物理地址，保护地址越界。 大多数嵌入式系统的处理器没有MMU，即使系统中含有这些硬件也没采用，因此不能使用虚拟存管理技术，只能采用实存管理，直接访问实际的物理地址。 每个任务运行前，必须为它分配足够的连续地址空间，运行时全部载入嵌入式操作系统没有内存保护，所有任务共享一个运行空间，任何 一个任务都可能破坏其它任务的代码、数据或堆栈，甚至破坏内核代码或数据结构，导致整个系统工作异常，或使系统崩溃。 由此可见，开发嵌入式系统时， 内存管理非常重要。内存如何分配和释放，才能保证内存碎片少，且不会导致内存丢失 ，每个任务的堆栈如何安排，如何保证不侵犯其它程序包括系统程序和数据的地址空间，才能保证程序不会破坏系统或其它程序的正常工作，这些都是内存管理所要考虑的问题

 

内存管理模块管理系统的内存资源，它是操作系统的核心模块之一。主要包括内存的初始化、分配以及释放。

嵌入式系统不同于一般的桌面系统，对内存分配有如下要求： 

①快速性： 嵌入式系统对实时性的保证，要求简单、快速地分配内存。在嵌入式系统中，不可能采用通用操作系统中复杂而完善的内存分配策略。 

②可靠性：内存分配的请求必须得到满足，如果分配失败可能会带来灾难性的后果。 

③高效性：嵌入式系统中内存是有限、昂贵的资源，内存分配要尽可能地少浪费。



### 操作系统对内存管理

​	现代操作系统能够同时运行多个程序，程序被运行时，需要占用内存的一块空间，如果同时运行的程序太多，物理内存可能装不下，因此出现了两种技术，交换技术和虚拟内存。

一、 交换技术

​	交换技术：就是指当内存满了以后，就将一个程序从内存换出，将另一个程序放入内存，换出的内存数据保存在硬盘上，当该程序再次被换入的时候，就将硬盘上的数据拷贝到内存。

二、 虚拟内存

​	虚拟内存：操作系统为了管理内存，给每个进程都分配独立的地址空间，对32位的系统而言，这个空间的大小是4GB。这4GB并不是实际的物理内存，实际上并不存在，因此有虚拟内存这一名称。

​	虚拟地址空间的地址称为逻辑地址，实际物理内存(就是内存条的大小)的地址空间称为物理地址。虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框。虚拟地址的页面通过一个页表映射物理内存的页框，页表中保存着两者的对应关系。逻辑地址是CPU使用的地址，当进程要访问该进程地址空间里的某个地址时时候，将该地址的值传递给CPU，CPU访问该地址时，会经过MMU将逻辑地址转换为物理地址，之前说的页表就保存在MMU中，操作系统为每个进程都维护一个页表。



### 相关算法

从分配的内存是否连续，可以分为两大类。

1.连续内存管理：为进程分配的内存空间是连续的，但这种分配方式容易形成内存碎片（碎片是难以利用的空闲内存，通常是小内存），降低内存利用率。连续内存管理主要分为单一连续内存管理和分区式内存管理两种。

2.非连续内存管理：将进程分散到多个不连续的内存空间中，可以减少内存碎片，内存使用率更高。如果分配的基本单位是页，则称为分页内存管理；如果基本单位是段，则称为分段内存管理。

当前的操作系统，普遍采用非连续内存管理方式。以往，由于嵌入式系统内存较小，而非连续内存管理对于内存分配粒度较大，所有嵌入式系统一般采用连续内存管理。不过，随着嵌入式系统内存的逐渐增大，其实使用连续性内存管理方式会更高效，所以，我们组决定选择非连续内存管理方式。

 非连续分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。在分页存储管理方式中，如果不具备页面对换功能，则称为基本分页存储管理方式，或纯分页管理方式。

### 基本分页存储管理方式

固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。为尽量避免碎片的产生，引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

分页方法与固定分区技术不同点在于：块的大小相对于分区小很多，而且进程也按照块进行划分，进程运行时，按照块申请主存可用空间并执行。与分区留在较大的内部碎片不同，分页方式只会在最后一个主存块上留下页内碎片。

##### 1 分页存储的几个基本概念

###### 1.1 页面和页面大小

进程中的块称为页(Page)，内存中的块称为页框或页帧（Page Frame）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，页与页框的一一对应。

为方便地址转换，页面大小应是2的整数幂，通常是512B~8KB。同时页面大小应该适中，需要进行空间效率和时间效率的权衡。如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。

###### 1.2 地址结构

分页存储管理的逻辑地址结构如图所示：

![image-20220408132748276](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132748276.png)


 地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32 位，其中011位为页内地址，即每页大小为4KB；1231位为页号，地址空间最多允许有2^20(1M)页。



###### 1.3 页表

为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。

进程通过查表得到每页在内存中的物理块号。由页表实现了从页号到物理块号的地址映射。如下图所示：

![image-20220408132811231](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132811231.png)





##### 2 基本地址变换机构

地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。转换过程中，业内偏移是固定的，需要完成由页号到块号的变换。

![image-20220408132830219](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132830219.png)

在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

- 计算页号P(P=A/L)和页内偏移量W (W=A%L)。
- 比较页号P和页表长度M，若P >= M，则产生越界中断，否则继续执行。
- 页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。
- 计算E=b*L+W，用得到的物理地址E去访问内存。

以上整个地址变换过程均是由硬件自动完成的。

##### 3 具备快表的地址变换机构

若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定所存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。这种方法比通常执行指令的速度慢了一半。

为加速地址变换的过程，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器(TLB)，用来存放当前访问的若干页表项。与此对应，主存中的页表也常称为慢表，配有快表的地址变换机构如图所示：

![image-20220408132841574](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132841574.png)



在具有快表的分页机制中，地址的变换过程：

- CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。
- 如果在快表中找到匹配的页号，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。
- 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。一般快表的命中率可以达到90%以上，这样，分页带来的速度损失就降低到10%以下。

##### 4 两级和多级页表

现代大多数计算机系统都支持非常大的逻辑地址空间（232~264），在这样的环境下，页表就变得非常大，要占很大的内存空间。32 位逻辑地址空间、页面大小4KB、页表项大小4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要2^20个页表项。也就是说，每个进程仅页表这一项就需要4MB主存空间，这显然是不切实际的。

此问题解决分两方面：一方面，只将当前需要的部分表项调入内存，其余的页表仍然驻留在磁盘上，需要时再调入。另一方面，需要对页表映射的思想进一步延伸，就可以得到二级分页。

二级页表将页表的10页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系。上一级页表只需要1页就足够（可以存储2^10=1024个页表项）。在进程执行时，只需要将这1页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再调入内存。

![image-20220408132901635](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132901635.png)

对二级页表再进行拓展，得到多级页表。64位计算机通常将可寻址存储空间减少为45位长度，这样可以使用三级页表结构来实现分页存储管理。

### 基本分段存储管理方式

分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

##### 1 分段

段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。

下图中，段号是16位，段内偏移量是为16位，则一个作业最多可有216=65536个段，最大段长为64KB。

![image-20220408132911126](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132911126.png)

在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。

##### 2 段表

每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。段表的内容如图所示：

![image-20220408132937331](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132937331.png)

段表用于实现从逻辑段到物理内存区的映射。在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。

![image-20220408132955732](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408132955732.png)

##### 3 地址变换机构

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：

- 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。
- 比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。
- 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>=C，则产生越界中断，否则继续执行。
- 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。
   分段系统的地址变换过程如下图所示：

![image-20220408133022037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408133022037.png)

##### 4 段的共享与保护

在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。

不能修改的代码称为纯代码或可重入代码（它不属于临界资源）。这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享。（需要修改数据时，每个访问进程必须配置局部数据区，并在执行中可能改变的部分拷贝到该区域）

与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。

### 段页式管理方式

页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。

在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，如图所示：

![image-20220408133036540](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408133036540.png)

在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量：

![image-20220408133047644](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408133047644.png)

在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。

![image-20220408133102842](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220408133102842.png)







### Rust编程语言

Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的程序设计风格。

![image-20220405213431098](D:/OSH大作业/调研报告/pics/image-20220405213431098.png)



#### rust优点：

##### 高性能

Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。

##### 可靠性

Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让程序员在编译期就能够消除各种各样的错误。

##### 生产力

Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。



### 树莓派

树莓派（英语：Raspberry Pi）英国树莓派基金会开发的微型单板计算机，目的是以低价硬件及自由软件促进学校的基本计算机科学教育。

![image-20220405213528585](D:/OSH大作业/调研报告/pics/image-20220405213528585.png)

树莓派系列计算机每一代均使用博通（Broadcom）出产的ARM架构处理器，如今生产的机型（树莓派4B）内存在2GB和8GB之间，主要TF卡作为系统存储媒体（初代使用SD卡），配备USB接口和HDMI的视频输出（支持声音输出），内置Ethernet/WLAN/Bluetooth网络链接的方式（依据型号决定），并且可使用多种操作系统。产品线型号分为A型、B型、Zero型和ComputeModule计算卡。



### RT-Linux

RTLinux（AReal-Time Linux,亦称作实时Linux）是Linux中的一种实时操作系统。它由新墨西哥矿业及科技学院的V. Yodaiken开发。RTLinux有一个由社区支持的免费版本，称为RTLinux Free，以及一个来自FSMLabs的商业版本，称作RTLinux Pro。

RT-Linux已经成功地应用于航天飞机的空间数据采集、科学仪器测控和电影特技图像处理等广泛领域，在电信、工业自动化和航空航天等实时领域也有成熟应用。随着信息技术的飞速发展，实时系统已经渗透到日常生活的各个层面，包括传统的数控领域、军事、制造业和通信业，甚至连潜力巨大的信息家电、媒体广播系统和数字影像设备都对实时性提出了愈来愈高的要求。

RT-Linux开发者并没有针对实时操作系统的特性而重写Linux的内核，因为这样做的工作量非常大，而且要保证兼容性也非常困难。将linux的内核代码做一些修改，将linux本身的任务以及linux内核本身作为一个优先级很低的任务，而实时任务作为优先级最高的任务。即在实时任务存在的情况下运行实时任务，否则才运行linux本身的任务。RT-Linux能够创建精确运行的符合POSIX.1b标准的实时进程；并且作为一种遵循GPL v2协议的开放软件，可以达GPL v2协议许可范围内自由地、免费地使用、修改和再发生。

它是Linux在实时性方面的扩展，采用已获得专利的双核技术:一个微型的RTLinux内核把原始的Linux内核作为它在空闲时的一个线程来运行。这开启了在两个不同的内核层面上――实时的RTLinux内核和常用的，非实时的Linux内核――运行不同程序的新方式。原始的Linux内核通过RTLinux内核访问硬件。这样，所有硬件实际上都是由RTLinux来进行管理的。有两种不同的RTLinux版本：RTLinux/Free(或者RTLinux/Open)和RTLinux/Pro. RTLinux/Pro是一个由FSMLabs开发的完全商业版本的实时linux。RTLinux/Free是一个由社区开发的开源版本。

现有的Linux是一个通用的操作系统，虽然它采用了许多技术来提高系统的运行和反应速度，但它本质上不是一个实时操作系统，应用于嵌入式环境中还存在诸多的不足。具体表现如下：

### 关中断问题

在系统调用中，为了保护临界区资源，Linux处于内核临界区时，中断会被系统屏蔽，这就意味着如果当前进程正处于临界区，即使它的优先级较低，也会延迟高优先级的中断请求。在实时应用中，这是一个十分严重的问题。

### 进程调度问题

Linux采用标准的UNIX技术使得内核是不可抢占的。采用基于固定时间片的可变优先级调度，不论进程的优先级多么低，Linux总会在某个时候分给该进程一个时间片运行，即使同时有可以运行的高优先级进程，它也必须等待低优先级进程的时间片用完，这对一些要求高优先级进程立即抢占CPU的实时应用是不能满足要求的。

### 时钟问题

Linux为了提高系统的平均吞吐率，将时钟中断的最小间隔设置为10ms，这对于一个周期性的实时任务，间隔要求小于10ms时，就不能满足实时任务的需要。如果要把时钟 的间隔改小以满足周期性的实时任务的需要，由于Linux的进程切换比较费时，时钟中断越频繁，而花在中断处理上的时间就越多,系统的大部分时间是调用进程调度程序进行进程调度而不能进行正常的处理。

**RTLinux的特点**

在Linux 操作系统中，调度算法（基于最大吞吐量准则）、设备驱动、不可中断的系统调用、中断屏蔽以及虚拟内存的使用等因素，都会导致系统在时间上的不可预测性，决定了Linux操作系统不能处理硬实时任务。RTLinux为避免这些问题，在Linux内核与硬件之间增加了一个虚拟层（通常称作虚拟机），构筑了一个小的、时间上可预测的、与Linux内核分开的实时内核，使得在其中运行的实时进程满足硬实时性。并且RTLinux和Linux构成一个完备的整体，能够完成既包括实时部分又包括非实时部分的复杂任务。

### 实现机理

RT-Linux对Linux内核进行改造，将Linux内核工作环境做了一些变化，如图1所示：

![image-20220406221513957](D:/OSH大作业/调研报告/pics/image-20220406221513957.png)

​																		图1 RTLinux对Linux内核改变

RTLinux有两种中断：硬中断和软中断。软中断是常规Linux内核中断。它的优点在于可无限制地使用Linux内核调用。硬中断是安装实时Linux的前提。依赖于不同的系统，实时Linux下硬中断的延迟是15μs。

![image-20220406221553406](D:/OSH大作业/调研报告/pics/image-20220406221553406.png)

​																				图2 RTLinux的体系结构

RTLinux的体系结构如图2所示。RTLinux的设计思想是:应用硬件的实时约束将实时程序分割成短小简单的部分,较大部分承担较复杂的任务。根据这一原则,将应用程序分为硬实时和软实时（即程序）2个部分。

**硬实时的实现：**

![image-20220406221703239](D:/OSH大作业/调研报告/pics/image-20220406221703239.png)

​																				图3 RT-FIFO结构图

图3所示的是RTFIFO结构图。RTLinux将标准Linux内核作为简单实时操作系统（RTOS）（或叫子内核）里优先权最低的线程来运行，从而避开了Linux内核性能的问题。 从图3可以看出，RTLinux拥有两个内核。这就意味着有两组单独的API，一个用于Linux环境，另一个用于实时环境。此外，为保证实时进程与非实时Linux进程不顺序进行数据交换，RTLinux引入了RT-FIFO队列。RT-FIFO被Linux视为字符设备，最多可达150个，分别命名为/dev/rtf0、/dev/rtf1……/dev/rtf63。最大的RT-FIFO数量在系统内核编译时设定。

RTLinux程序运行于用户空间和内核态两个空间。RTLinux提供了应用程序接口。借助这些API函数将实时处理部分编写成内核模块，并装载到RTLinux内核中，运行于RTLinux的内核态。非实时部分的应用程序则在Linux下的用户空间中执行。这样可以发挥Linux对网络和数据库的强大支持功能。

**软实时的实现:**

RTLinux通过一个高效的、可抢先的实时调度核心来全面接管中断，并把Linux作为此实时核心的一个优先级最低的进程运行。当有实时任务需要处理时，RTLinux运行实时任务；无实时任务时，RTLinux运行Linux的非实时进程。其系统结构见图4。

RTLinux在默认的情况下采用优先级的调度策略，即系统调度器根据各个实时任务的优先级来确定执行的先后次序。优先级高的先执行，优先级低的后执行，这样就保证了实时进程的迅速调度。同时RTLinux也支持其它的调度策略，如最短时限最先调度（EDP）、确定周期调度（RM）（周期段的实时任务具有高的优先级）。RTLinux将任务调度器本身设计成一个可装载的内核模块，用户可以根据自己的实际需要，编写适合自己的调度算法。

![image-20220406221836888](D:/OSH大作业/调研报告/pics/image-20220406221836888.png)

​																			图4 RTLinux系统结构图

对于一个操作系统而言，精确的定时机制虽然可以提高任务调度器的效率，但会增加CPU处理定时中断的时间开销。RTLinux对时间精度和时钟中断处理的时间开销进行了折中考虑。不是像Linux那样将8254定时器设计成10ms产生一次定时中断的固定模式，而是将定时器芯片设置为终端计时中断方式。根据最近的进程的时间需要，不断调整定时器的定时间隔。这样不仅可以获得高定时精度，同时中断处理的开销又最小。



## 立项依据

随着智能硬件、物联网行业的迅猛发展, 嵌入式系统在各个领域都得到了广泛的应用。嵌入式操作系统可以帮助嵌入式设备更好地完成任务的调度，从而更高效地完成任务。然而，一开始由于嵌入式设备内存较少，一些主流的嵌入式操作系统如FreeRTOS并没有内存管理单元。随着时代的发展，内存的成本越来越低，嵌入式设备也在向着内存增加的方向发展。所以，按照当前的趋势，嵌入式操作系统也应该有自己的内存管理单元。嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。于是，我们小组决定为FreeRTOS编写一个内存管理单元，从而让其有更强大的任务调度能力。由于Rust是一门高效而且安全的语句，我们将使用Rust来进行编写。

嵌入式系统内存配置较小,不能采用一般桌面系统的内存管理方式,选取合适的内存管理策略在嵌入式系统设计中起着重要的作用。因此，我们组的题目是十分符合现实趋势的。

微内核的模块化使用也是一个十分高效的内核实现方式，它可以大大降低功耗，而这在操作系统的应用中无疑是非常理想的。而内核的模块化挂载也是一种完全可行的实现方式。所以，我们组使用微内核调用宏内核的路线是实用而且可行的。

 

## 重要性分析



### 为FreeRTOS添加MMU：

当今的嵌入式设备内存在不断扩大。

![image-20220406222205134](D:/OSH大作业/调研报告/pics/image-20220406222205134.png)



CPU:全志R16，主频高达1.2GHZ
内存：DDR3/DDR3L 1G,可扩展至2G
存储：4GB EMMC,可兼容至64GB
供电电压：5V
尺寸：42.4mm x 45.4mm
工作温度：0° c~80℃
存储温度：-40° C~100° C



以上为一个扫地机器人的参数，可以看出扫地机器人已经拥有1G的内存。

![image-20220406173626271](D:/OSH大作业/调研报告/pics/image-20220406173626271.png)



产品型号 InBio510
核心板 ZMM220EMC核心板（128M内存，FLASH为256M）

上图为InBio5系列门禁控制器，是一款区域型门禁系统。可以看出，它的内存也有128M

从上面两个例子可以看出，目前嵌入式系统的内存已经比较大了，所以嵌入式操作系统也需要有合适的内存管理单元。

现代操作系统普遍采用虚拟内存机制，这需要处理器中的MMU（Memory Management Unit，内存管理单元）提供支持，下面简要介绍MMU的作用。

首先引入两个概念，虚拟地址和物理地址。如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA）。如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA。

如果是32位处理器，则内地址总线是32位的，与CPU执行单元相连（图中只是示意性地画了4条地址线），而经过MMU转换之后的外地址总线则不一定是32 位的。也就是说，虚拟地址空间和物理地址空间是独立的，32位处理器的虚拟地址空间是4GB，而物理地址空间既可以大于也可以小于4GB。

MMU除了做地址转换之外，还提供内存保护机制。各种体系结构都有用户模式（User Mode）和特权模式（Privileged Mode）之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在CPU处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，访问权限又分为可读、可写和可执行三种。这样设定好之后，当CPU要访问一个VA时，MMU会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成PA，否则不允许访问，产生一个异常（Exception）。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由CPU内部产生，中断产生的原因和CPU当前执行的指令无关，而异常的产生就是由于CPU当前执行的指令出了问题，例如访问内存的指令被MMU检查出权限错误，除法指令的除数为0等都会产生异常。

通常操作系统把虚拟地址空间划分为用户空间和内核空间，例如x86平台的Linux系统虚拟地址空间是0x00000000~0xffffffff，前 3GB（0x00000000~0xbfffffff）是用户空间，后1GB（0xc0000000~0xffffffff）是内核空间。用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。这样可以保护内核，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性。CPU在产生中断或异常时不仅会跳转到中断或异常服务程序，还会自动切换模式，从用户模式切换到特权模式，因此从中断或异常服务程序可以跳转到内核代码中执行。事实上，整个内核就是由各种中断和异常处理程序组成的。总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。



综上，MMU是十分重要的，它可以为操作系统内存调度提供很大方便，而且可以让内存访问更加安全。

目前，嵌入式操作系统多种多样，使用于许多不同场合。

嵌入式中有一部分是通过对Linux的改进来实现实时性。

inux是分时系统，不过可以通过配置内核改成实时。
嵌入式Linux 系统是在原来Linux的发行版本之上进行了优化和改进的，用于嵌入式的移动终端等设备的嵌入式Linux系统现在基本上都是实时性较高的，但有些LiNUX系统还是分时系统。

实时操作系统（RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系 统作出快速响应，并控制所有实时任务协调一致运行的操作系统。因而，提供及时响应和高可靠性是其主要特点。实时操作系统有硬实时和软实时之分，硬实时要求 在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可。我们通常使用的操作系统在经过一定改 变之后就可以变成实时操作系统。
实时操作系统是保证在一定时间限制内完成特定功能的操作系统。例如，可以为确保生产线上的机器人能获取某个物 体而设计一个操作系统。在“硬”实时操作系统中，如果不能在允许时间内完成使物体可达的计算，操作系统将因错误结束。在“软”实时操作系统中，生产线仍然 能继续工作，但产品的输出会因产品不能在允许时间内到达而减慢，这使机器人有短暂的不生产现象。一些实时操作系统是为特定的应用设计的，另一些是通用的。 一些通用目的的操作系统称自己为实时操作系统。但某种程度上，大部分通用目的的操作系统，如微软的Windows NT或IBM的OS/390有实时系统的特征。这就是说，即使一个操作系统不是严格的实时系统，它们也能解决一部分实时应用问题。

任务调度策略是直接影响实时性能的因素。尽管调度算法多种多样，但大多由单调率算法(RM)和最早期限优先算法(EDF)变化而来。前者主要用 于静态周期任务的调度，后者主要用于动态调度，在不同的系统状态下两种算法各有优劣。在商业产品中采用的实际策略常常是各种因素的折中。
　　QNX 提供POSIX.1b标准进程调度：
　　32个进程优先级；
　　抢占式的、基于优先级的正文切换；
　　可选调度策略：FIFO、轮转策略、适应性策略。
　　LynxOS 其调度策略为：
　　LynxOS支持线程概念，提供256个全局用户线程优先级；
　　硬实时优先级调度：在每个优先级上实现了轮转调度、定量调度和FIFO调度策略；
　　快速正文切换和阻塞时间短；
　　抢占式的RTOS核心。
　　RT－Linux
　　在操作系统之下实现了一个简单的实时核心，Linux本身作为一个可抢占的任务在核内运行，优先级最低，随时会被高优先级任务抢占。
　　用户可自行编写调度程序，它们可实现为可加载的核心模块；
　　已实现的调度程序有：基于优先级的抢占式调度和EDF调度；
　　基于优先级的调度使用”单调率算法”，它直接支持周期任务。
　　KURT－Linux
　　可运行在两种状态之下：通常状态和实时状态。在通常状态下，所有进程都可以运行，但某些核心服务将带来中断屏蔽的不可预期性。实时模式只允许实时进程运行。
　　支持FIFO调度策略、轮转调度策略和UNIX分时调度策略；
　　增加了SCHED－KURT调度策略，这是一种静态调度策略，使用一个特殊的调度文件记录预先定义好的待调度进程的参数。
　　从以上简略描述可以看出，前三种调度策略实现较规范，特别是两种商业RTOS，遵循或部分遵循POSIX.1b实时调度标准。

下面来说说FreeRTOS的优点。

FreeRTOS的设计小巧且简易，整个核心代码只有3到4个C文件，为了让代码容易阅读、移植和维护，大部分的代码都是以C语言编写，只有一些函数（多数是架构特定排班副程序）采用汇编语言编写。

FreeRTOS提供许多方法以实现多线程（threads）、多作业（task）、互斥锁（mutex）、信号量（semaphore）和软件计时器（software timer），有个为低耗电应用程序提供的无嘀嗒（tick-less）模式，线程的优先权管理也有支持，此外，FreeRTOS提供了四种存储器配置的模式：

FreeRTOS中没有一些像Linux、Microsoft Windows等典型操作系统具有的先进特征，例如设备驱动程序、先进存储器管理机制、用户管理和网络管理，FreeRTOS着重在执行的简洁与速度，FreeRTOS有时会被视为是一个‘线程库’而非‘操作系统’，尽管可以找到命令行接口和类似POSIX I/O 接口的插件。

FreeRTOS实现了多线程，主程序会在规律的短时间区间内调用一个线程时计方法，这个方法会以循环制依照任务的优先级进行任务切换，一般来说，这个短时间区间介于 1/1000 秒与 1/100 秒之间，透过一个硬件时计中断来计时，但这个区间经常随着特定的应用而改变。

从FreeRTOS官网（FreeRTOS.org（页面存档备份，存于互联网档案馆））所下载到的代码包含准备用来移植或编译的配置文件和演示代码，让用户可以快速地进行应用程序设计。

综上，FreeRTOS是一个发展前景很好的嵌入式操作系统，我们对它的改进也是十分重要的。

Linux内核相对于FreeRTOS由于实现比较复杂，其功耗也相对较高，但它的功能也相对较为完善。而如果能把FreeRTOS作为微内核，在操作系统之下实现一个简单的实时核心，Linux本身作为一个可抢占的任务在核内运行，优先级最低，随时会被高优先级任务抢占。用户可自行编写调度程序，它们可实现为可加载的核心模块。这样就可以实现能耗和功能的权衡。

##  相关工作

1. 基于Ramakrishna提出的smart DM allocator的改进 ，动态内存管理中利用统计数据来提高内存管理性能，通过基于过去数据的启发式算法来预测某个大小内存块的生命期长短, 根据预测结果在相应的内存区进行分配, 其中生命期短的内存块即为频繁申请释放的内存块。

2. 对可生存嵌入式系统内存管理设计与实现：可生存性是指系统在受到来自外部或内部的破坏时，在一部分任务产生故障、错误或失效的情况下，能及时采取措施，保证关键任务及时完成的能力。这种能力对嵌入式系统特别是安全关键嵌入式系统显得尤其重要。与其它系统相比，嵌入式系统对成本、功耗、体积等有严格限制，采用增加硬件部件来提高系统可生存性的方法将增加系统的成本，功耗等。采用改进软件系统来提高系统可生存性成为一种理想的方法。改进内存管理来提高对嵌入式系统生存性的支持作用是一种可行方案。

3. 针对工业物联网高速通信中出现流量堵塞如何高效存储的问题，引入内存管理的方法。

4. 基于TLSF算法改进的动态内存管理算法，提升内存分配效率,同时通过增加校验,可以检测系统中可能存在的内存泄漏问题,提升系统稳定性

5. 基于线段树的高效内存管理方法。现有的内存管理的工作多集中在内存分配的效率上,实时性较好,但易产生内存碎片。而该方法将内存地址空间划分为内存段,建立内存管理线段树,基于所建立的内存管理线段树,进行高效灵活的内存分配和回收管理,减少了内存碎片的产生。另外,针对线段树空间开销大的问题,提出了线段树空间优化的方法。

6. 多kernel操作系统的已有实现方法

    

   实现1：

   ​	多核双Kernel，两个OS分别运行在自己的核上，两者通过共享内存进行系统间通讯

   ​	某种意义上是一种分布式

   

   ![image-20220406222711233](D:/OSH大作业/调研报告/pics/image-20220406222711233.png)

    

   实现2：

   ​	单核双Kernel，将其中一个OS嵌入另一个OS，共同吸收两者优点

   ​	目前已有的实现：VxWIN，其将xWorks系统嵌入windows系统，能够在windows下使用xWorks达到部分的高实时性

    

   ![image-20220406222724783](D:/OSH大作业/调研报告/pics/image-20220406222724783.png) 

   ![image-20220406222755240](D:/OSH大作业/调研报告/pics/image-20220406222755240.png) 

## 参考文献



《嵌入式实时系统内存管理策略》

《嵌入式实时系统中动态内存管理算法的设计与实现》

《嵌入式系统新型动态内存管理机制的研究》

《可生存嵌入式 OS 内存管理设计与实现》

《工业物联网中的缓冲内存管理设计与实现》

《基于TLSF算法改进的动态内存管理算法研究》

《基于线段树的高效内存管理算法及其空间优化》

[VxWin White Paper JN 23058 - Kuka (yumpu.com)](https://www.yumpu.com/en/document/read/5333799/vxwin-white-paper-jn-23058-kuka)

[VxWin White Paper JN 23058 - Kuka (yumpu.com)](https://www.yumpu.com/en/document/read/5333799/vxwin-white-paper-jn-23058-kuka)

https://zh.wikipedia.org/zh-cn/FreeRTOS

https://baike.baidu.com/item/FreeRTOS

[树莓派 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/zh-cn/树莓派)

https://www.rust-lang.org/zh-CN/

[https://baike.baidu.com/item/Rust%E8%AF%AD%E8%A8%80/9502634](https://baike.baidu.com/item/Rust语言/9502634)

[操作系统内存管理(思维导图详解)_hguisu的博客-CSDN博客_内存管理](https://blog.csdn.net/hguisu/article/details/5713164?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

[操作系统的内存管理算法_strongerHuang的博客-CSDN博客](https://blog.csdn.net/ybhuangfugui/article/details/107551847)

[嵌入式学习记录：内存管理单元（MMU）介绍_Linux编程_Linux公社-Linux系统门户网站 (linuxidc.com)](https://www.linuxidc.com/Linux/2011-09/43525.htm)

[13 内存非连续分配管理方式 - 简书 (jianshu.com)](https://www.jianshu.com/p/7bfe9bb44c07)





